<html lang="en">
<head>
  <title>Ballerina 1.2 Experimental Features</title>
  <meta charset="utf-8">
  <style type="text/css">
    body { font-family: sans-serif; line-height: 1.38;  }
    pre.grammar code, code.grammar { background-color: #D0D0D0; }
    pre, code { font-family: Consolas, monospace; }
    table { border: solid thin; border-collapse: collapse; }
    td, th { border: solid thin; padding: 0.5em; }
    p.status { font-size: large; font-weight: bold; }
  </style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i&amp;display=swap">
<link rel="stylesheet" href="style/ballerina-language-specification.css">
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script><script src="style/ballerina-language-specification.js"></script>
</head>
<body>
<h1>Ballerina 1.2 Experimental Features</h1>
<p>
Primary contributors:
</p>
<ul>
<li>Sanjiva Weerawarana, <a href="mailto:sanjiva@weerawarana.org">sanjiva@weerawarana.org</a>
</li>
<li>Sameera Jayasoma, <a href="mailto:sameera@wso2.com">sameera@wso2.com</a>
</li>
<li>Hasitha Aravinda, <a href="mailto:hasitha@wso2.com">hasitha@wso2.com</a>
</li>
</ul>
<p>
Copyright Â© 2018, 2019, 2020 <a href="https://wso2.com/">WSO2</a>
</p>
<p>
Licensed under the <a href="https://creativecommons.org/licenses/by-nd/4.0/">Creative Commons
Attribution-NoDerivatives 4.0 International</a> license
</p>

<section class="toc"><h2>Table of contents</h2>
<ul>
<li>1. <a href="#introduction">Introduction</a>
</li>
<li>4. <a href="#actions_statements">Actions and statements</a><ul><li>2.1 <a href="#transactions">Transaction statement</a><ul>
<li>2.1.1 <a href="#section_2.1.1">Initiated transactions</a>
</li>
<li>2.1.2 <a href="#section_2.1.2">Participated transactions</a>
</li>
<li>2.1.3 <a href="#section_2.1.3">Transaction propagation</a>
</li>
</ul>
</li></ul>
</li>
</ul></section>

<section>
<h2 id="introduction">1. Introduction</h2>
<p>This document describes features implemented experimentally in
Ballerina 1.2.</p>

</section>

<section>
<h2 id="actions_statements">4. Actions and statements</h2>

<pre class="grammar">statement := 
   <em>...</em>
   | transaction-stmt
   | transaction-control-stmt
</pre>

<section>
<h3 id="transactions">2.1 Transaction statement</h3>

<pre class="grammar">transaction-stmt := <code>transaction</code> trans-conf? block-stmt trans-retry?
transaction-control-stmt := retry-stmt | abort-stmt
trans-conf := trans-conf-item (<code>,</code> trans-conf-item)*
trans-conf-item := trans-retries | trans-oncommit | trans-onabort
trans-retries := <code>retries</code> <code>=</code> expression
trans-oncommit := <code>oncommit</code> <code>=</code> identifier
trans-onabort := <code>onabort</code> <code>=</code> identifier
trans-retry := <code>onretry</code> block-stmt
retry-stmt := <code>retry</code> <code>;</code>
abort-stmt := <code>abort</code> <code>;</code>
</pre>
<p>
A transaction statement is used to execute a block of code within a 2PC
transaction. A transaction can be established by this statement or it may
inherit one from the current worker.
</p>
<section>
<h4 id="section_2.1.1">2.1.1 Initiated transactions</h4>
<p>
If no transaction context is present in the worker then the transaction
statement starts a new transaction (i.e., becomes the initiator) and executes
the statements within the transaction statement.
</p>
<p>
Upon completion of the block the transaction is immediately tried to be
committed. If the commit succeeds, then if there's an on-commit handler
registered that function gets invoked to signal that the commit succeeded. If
the commit fails, and if the transaction has not been retried more times than
the value of the retries configuration, then the on-retry block is executed and
the transaction block statement will execute again in its entirety. If there are
no more retries available then the commit is aborted the on-abort function is
called.
</p>
<p>
The transaction can also be explicitly aborted using an abort statement, which
will call the on-abort function and give up the transaction (without retrying).
</p>
<p>
If a retry statement is executed if the transaction has not been retried more
times than the value of the retries configuration, then the on-retry block is
executed and the transaction block statement will execute again in its entirety.
</p>
</section>
<section>
<h4 id="section_2.1.2">2.1.2 Participated transactions</h4>
<p>
If a transaction context is present in the executing worker context, then the
transaction statement joins that transaction and becomes a participant of that
existing transaction. In this case, retries will not occur as the transaction is
under the control of the initiator. Further, if the transaction is locally
aborted (by using the abort statement), the transaction gets marked for abort
and the participant will fail the transaction when it is asked to prepare for
commit by the coordinator of the initiator. When the initiating coordinator
decides to abort the transaction it will notify all the participants globally
and their on-abort functions will be invoked. If the initiating coordinator
decides to retry the transaction then a new transaction is created and the
process starts with the entire containing executable entity (i.e. resource or
function) being re-invoked with the new transaction context.
</p>
<p>
When the transaction statement reaches the end of the block the transaction is
marked as ready to commit. The actual commit will happen when the coordinator
sends a commit message to the participant and after the commit occurs the
on-commit function will be invoked. Thus, reaching the end of the transaction
statement and going past does not have the semantic of the transaction being
committed nor of it being aborted. Thus, if statements that follow the
transaction statement they are unaware whether the transaction has committed or
aborted.
</p>
<p>
When in a participating transaction, a retry statement is a no-op.
</p>
</section>
<section>
<h4 id="section_2.1.3">2.1.3 Transaction propagation</h4>
<p>
The transaction context in a worker is always visible to invoked functions. Thus
any function invoked within a transaction, which has a transaction statement
within it, will behave according to the "participated transactions" semantics
above.
</p>
<p>
The transaction context is also propagated over the network via the Ballerina
Microtransaction Protocol [XXX].
</p>
</section>
</section>
</section>

</body>
</html>
